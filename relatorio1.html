<div class="relatorio-container">
  <h2>Relat√≥rio 1 - Captura de Imagem e V√≠deo</h2>
  <h3><pre>
  Leonardo Severgnine Maioli - RA: 11201920579
  Ricardo Javurek Rihan - RA: 11201920897
  Tiago Luiz Silva de Araujo Pereira - RA: 11013316

  Laborat√≥rio realizado dias 16 e 18 de Junho, relat√≥rio finalizado dia 23 de Junho
  </pre></h3>
  <h2>Introdu√ß√£o</h2>
  <p>
    Este primeiro relat√≥rio tratou de experimentos focados em captura de im√°gem e v√≠deo atrav√©s de webcam, bem como sua manipula√ß√£o, mudando cores,
    velocidade de captura e afins. Os experimentos realizados foram seguindo um roteiro apresentado em aula dividido em duas partes, e tinha como objetivo estudar o uso
    do OpenCV e nos familiarizar com a visualiza√ß√£o e processamento de im√°gem e v√≠deo de forma geral. Foram fornecidos c√≥digos para tomarmos como base, que modificamos
     durante o experimento para adequar ao que necessitavamos. Os arquivos abaixo foram fornecidos como roteiro para a atividade, contendo o PDF que seguimos para realizar os experimentos,
     os c√≥digos iniciais e uma imm√°gem e v√≠deo que foram utilizados nos experimentos. Os experimentos consistiram inicialmente na leitura de im√°gem e v√≠deo, e ent√£o na captura das 
     mesmas atrav√©s de uma webcam conectada ao computador.
  </p>
  <h2>Arquivos base para reproduzir o procedimento:</h2>
  <ul>
    <li><a href="relatorio1/esza019_2025.2__Lab1_img_video_.pdf" download class="download-link">üìÑ Baixar Roteiro (PDF)</a></li>
    <li><a href="relatorio1/Lab1_arquivos.zip" download class="download-link">üì¶ Baixar C√≥digos Fonte (ZIP)</a></li>
  </ul>

    <h2>Procedimentos Experimentais</h2>
      <!-- Parte 1 - A -->

  <p>
    O primeiro experimento consiste na leitura de uma im√°gem utilizando o OpenCV. Para este, foram utilizadas a im√°gem messi5.jpg e o c√≥digo L1_1_img.py fornecidos acima. Para isto,
    o computador tem que ter o Python instalado, assim como OpenCV (pip install opencv-python) e numpy (pip install numpy). Feito isso, basta executar L1_1_img.py com o python, tendo
    a im√°gem que ser√° lida (no nosso caso, messi5.jpg) na mesma pasta que o c√≥digo. Ao realizarmos a leitura pela primeira vez, podemos ver que foi aberta uma janela do openCV que 
    exibe a im√°gem, por√©m ela √© exibida em preto e branco: 
  </p>
  <div class="image-container">
    <img src="relatorio1/messi5Original.png" alt="Imagem na leitura original" class="relatorio-image">
    <p class="image-caption"><em>Im√°gem lida pelo c√≥digo original, sem modifica-lo</em></p>
  </div>
  <p>
    Como podemos ver, a im√°gem veio em preto e branco. Vamos agora analisar o c√≥digo utlilzado. Na primeira linha depois dos imports, temos um imread, passando como parametro o 
    caminho para nossa im√°gem e em seguida um n√∫mero, 0. Como podemos ver na documenta√ß√£o do openCV, este segundo parametro que estamos passando trata da cor da im√°gem. O 0 consiste
    no preto e branco, portanto foi por isso que nossa im√°gem final apareceu desta forma. Para alterarmos isso podemos passar o parametro 1, que consiste no colorido padr√£o, ou podemos
    simplesmente n√£o passar mais nenhum argumento ap√≥s o caminho da im√°gem como o colorido √© o default do comando. Modificando nosso c√≥digo, podemos ver como a im√°gem √© lida novamente:
  </p>
  <div class="image-container">
    <img src="relatorio1/messi5.png" alt="Imagem" class="relatorio-image">
    <p class="image-caption"><em>Im√°gem lida pelo c√≥digo modificado</em></p>
  </div>
  Abaixo temos o c√≥digo com a mudan√ßa realizada:
  <div class="button-group">
    <button onclick="toggleSection('code1')">C√≥digo 1 Modificado</button>
  </div>
  <div id="code1" class="relatorio-section" style="display: none;">
      <code><pre>
      import numpy as np
      import cv2 as cv

      img = cv.imread('messi5.jpg')
      cv.imshow('image',img)
      k = cv.waitKey(0)
      if k == 27:         # wait for ESC key to exit
          cv.destroyAllWindows()
      elif k == ord('s'): # wait for 's' key to save and exit
          cv.imwrite('messigray.png',img)
          cv.destroyAllWindows()
    </pre></code>
  </div>
  <!-- Parte 1 - B -->

  <p>
    Em seguida, realizamos um experimento semelhante mas tratando de leitura de v√≠deo. Para isto, foram utilizados o segundo c√≥digo e o v√≠deo
    big_buck_bunny, ambos presentes nos arquivos fornecidos. Ao rodarmos o arquivo, podemos ver que o v√≠deo j√° √© apresentado normalmente e 
    em velocidade normal. Neste experimento, buscamos analisar como funciona a leitura de v√≠deos pelo openCV. Para isto, vamos tentar alterar
    a velocidade de reprodu√ß√£o do v√≠deo. Vendo o c√≥digo, que est√° inclusive comentado, podemos ver que a exibi√ß√£o do v√≠deo est√° sendo feita 
    por modo de exibi√ß√£o de frames, um de cada vez e em sequ√™ncia. Portanto, se queremos alterar a velocidade do v√≠deo, basta mudarmos o tempo
    que esperamos entre a exibi√ß√£o de um frame e do pr√≥ximo, portanto alterando o valor de time.sleep(1/25.0). Para demonstrar, alteramos o 
    valor para time.sleep(1/100.0), e como resultado ao rodar o programa tivemos um v√≠deo acelerado: 
  </p>

  <video controls width="640">
    <source src="relatorio1/big_buck_bunny_accelerated.mp4" type="video/mp4">
  </video>

  <div class="button-group">
    <button onclick="toggleSection('code2')">C√≥digo 2 Modificado</button>
  </div>
  <div id="code2" class="relatorio-section" style="display: none;">
    <code><pre>
      import time
      import numpy as np
      import cv2 as cv

      cap = cv.VideoCapture('big_buck_bunny.mp4')

      while(cap.isOpened()):
          ret, frame = cap.read()

          if ret==True:
              # show the frame
              cv.imshow('frame',frame)

              #wait next frame by 40ms - 25fps
              time.sleep(1/100.0) 

              if cv.waitKey(1) & 0xFF == ord('q'):
                  break
          else:
              break

      cap.release()
      cv.destroyAllWindows()cv.destroyAllWindows()
    </pre></code>
  </div>

    <!-- Parte 1 - C  e 2 - A e B -->
  <p>
    O proximo experimento consistiu em  conectar uma webcam ao computador e realizar a leitura e captura de im√°gens atrav√©s desta. Para isso, 
    foi usado o programa 3 fornecido. O programa fornecido j√° √© capaz de identificar a webcam e visualizar im√°gens atrav√©s desta, ent√£o apenas 
    precisamos modifica-lo para salvar a im√°gem que est√° sendo exibida quando quisermos. Para isso, utilizamos a fun√ß√£o imwrite do openCV.
    Inicialmente tentamos inserir uma outra linha com if cv.waitKey(1), verificando se o valor era igual a x, e ent√£o realizando um imwrite 
    passando o nome desejado e o frame previamente definido. Esta solu√ß√£o era capaz de salvar a imagem conforme desejado, mas notamos que 
    algumas vezes nosso click parecia n√£o ser registrado e s√≥ algumas vezes a imagem era salva. Percebemos que isto acontecia porque como 
    t√≠nhamos dois waitKeys, o programa estava alternando entre os dois e verificando apenas uma das teclas de cada vez. Para resolver este
    problema, definimos uma vari√°vel como o valor da waitKey, fora dos ifs, e ent√£o realizamos a verifica√ß√£o do valor da tecla recebida pela
    vari√°vel. Por fim, definimos um img_counter e utilizamos ele para iterar o nome da foto, para podermos salvar v√°rias fotos em seguida sem
    uma sobrescrever a outra por terem o mesmo nome. Utilizamos deste programa modificado para tirar fotos de todos do grupo:
  </p>

  <img class="profile-image" src="images/fotoDos3.png"></br>

  <div class="button-group">
    <button onclick="toggleSection('code3')">C√≥digo 3 Modificado</button>
  </div>
  <div id="code3" class="relatorio-section" style="display: none;">
          <pre><code>
            import numpy as np
            import cv2 as cv

            cap = cv.VideoCapture(0)
            img_counter = 0

            if not cap.isOpened():
                print("Cannot open camera")
                exit()

            while True:
                # Capture frame-by-frame
                ret, frame = cap.read()
                # if frame is read correctly ret is True
                if not ret:
                    print("Can't receive frame (stream end?). Exiting ...")
                    break

                # Display the resulting frame
                cv.imshow('frame', frame)

                cvVal = cv.waitKey(1)
                if cvVal == ord('q'):
                    break
                elif cvVal == ord('x'):
                    img_name = "foto{}.png".format(img_counter)
                    cv.imwrite(img_name, frame)
                    img_counter +=1

            # When everything done, release the capture
            cap.release()
            cv.destroyAllWindows()
          </code></pre>
    </div>
    <p>
      Seguindo ainda o script no PDF, escolhemos "avatares" para cada integrante do grupo, mostrando eles aqui na mesma sequ√™ncia da foto:
    </p>
    <img class="profile-image" src="images/avatarDos3.png">

    <!-- Parte 1 - D  e 2 - C -->

    <p>
      Por fim, realizamos experimentos com captura de v√≠deo. Para isso, tomamos como base o c√≥digo 4 fornecido. Por√©m, podemos ver que ao 
      rodarmos este, podemos notar que a im√°gem est√° sendo exibida de forma invertida, e o v√≠deo salvo est√° muito mais lento que a velocidade
      real:
    </p>
    <video controls width="640">
        <source src="relatorio1/saida.mp4" type="video/mp4">
    </video>
    <p>
      Olhamos o c√≥digo e vimos que o problema da imagem invertida se d√° pelo fato de usarem a fun√ß√£o cv.flip() para realizarem a invers√£o do 
      frame do v√≠deo, antes de rodar a fun√ß√£o write() no objeto do VideoWriter criado. [ frame = cv.flip(frame, 0) ] J√° o problema da 
      velocidade reduzida se d√° pelo fato do FPS do VideoWriter estar setado com um valor baixo de 10 fps, e foi resolvido aumentando esse 
      valor para 30. Ap√≥s realizarmos estas modifica√ß√µes, utilizamos de nosso c√≥digo alterado para gravar alguns v√≠deos de teste:
    </p>
    <div class="video-section">
    <h2>V√≠deos de Movimento</h2>

    <div class="video-container">
      <h3>Movimento r√°pido - Membro</h3>
      <video controls muted width="640">
        <source src="videos/Movimento_rapido_membro.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento r√°pido - Objeto</h3>
      <video controls muted width="640">
        <source src="videos/Movimento_rapido_objeto.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento lento - Membro</h3>
      <video controls muted width="640">
        <source src="videos/movimento-lento-membro.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento lento - Objeto</h3>
      <video controls muted width="640">
        <source src="videos/movimento-lento-objeto.mp4" type="video/mp4">
      </video>
    </div>
  </div>
  <div class="button-group">
    <button onclick="toggleSection('code4')">C√≥digo 4 Modificado</button>
  </div>
  <div id="code4" class="relatorio-section" style="display: none;">
          <pre><code>
            import numpy as np
            import cv2 as cv
            cap = cv.VideoCapture(0)

            # Get current width of frame
            width = cap.get(cv.CAP_PROP_FRAME_WIDTH)   # float
            # Get current height of frame
            height = cap.get(cv.CAP_PROP_FRAME_HEIGHT) # float
            # Define Video Frame Rate in fps
            fps = 30.0

            # Define the codec and create VideoWriter object
            fourcc = cv.VideoWriter_fourcc(*'XVID')
            out = cv.VideoWriter('saida.avi', fourcc, fps, (int(width),int(height)) )

            while cap.isOpened():
                ret, frame = cap.read()
                if not ret:
                    print("Can't receive frame (stream end?). Exiting ...")
                    break
                frame = cv.flip(frame, 1)
                # write the flipped frame
                out.write(frame)
                cv.imshow('frame', frame)
                if cv.waitKey(1) == ord('q'):
                    break

            # Release everything if job is finished
            cap.release()
            out.release()
            cv.destroyAllWindows()
          </code></pre>
    </div>
    <h2>An√°lise e Discuss√£o</h2>
    <p>
      A partir dos experimentos realizados, foi poss√≠vel observar como par√¢metros simples nos comandos do OpenCV, como o valor do 
      <code>imread()</code> ou a frequ√™ncia de <code>waitKey()</code> e <code>sleep()</code>, afetam diretamente a forma como as imagens e 
      v√≠deos s√£o processados e exibidos. Durante os testes com captura de imagem, a import√¢ncia de um controle adequado das teclas pressionadas
       ficou evidente, j√° que duplica√ß√µes ou m√°s leituras podem comprometer a funcionalidade esperada. Da mesma forma, a manipula√ß√£o do v√≠deo 
       mostrou que o entendimento de FPS e orienta√ß√£o do frame (flip) √© essencial para obter resultados realistas. As altera√ß√µes realizadas nos
        c√≥digos base foram fundamentais para tornar os programas mais responsivos e adequados aos objetivos da atividade.
    </p>
  <h2>Conclus√µes</h2>
  <p>
    Este primeiro experimento permitiu uma introdu√ß√£o pr√°tica ao OpenCV, destacando aspectos importantes do processamento de imagens e v√≠deos,
     como leitura, exibi√ß√£o, modifica√ß√£o e grava√ß√£o. Ao trabalhar com diferentes formatos de entrada e sa√≠da, o grupo p√¥de compreender o 
     funcionamento interno das opera√ß√µes b√°sicas da biblioteca, al√©m de enfrentar e solucionar problemas comuns no uso de webcams e v√≠deos.
      As atividades tamb√©m favoreceram o aprendizado pr√°tico de conceitos como FPS, codificadores de v√≠deo, e a influ√™ncia da intera√ß√£o do 
      usu√°rio sobre o comportamento dos programas. De forma geral, os objetivos da atividade foram atingidos com sucesso.
  </p>
    <div class="referencias">
    <h2>Refer√™ncias</h2>
    <ul>
      <li>MINICHINO, J.; HOWSE, J. <em>Learning OpenCV 3 Computer Vision with Python</em>, 2nd Ed, Packt Publishing, 2015.</li>
      <li><a href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html" target="_blank">Tutorial OpenCV e Python</a></li>
      <li><a href="https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html" target="_blank">Getting Started with Images</a></li>
      <li><a href="https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html" target="_blank">Getting Started with Videos</a></li>
      <li><a href="https://convertio.co/pt/download/d7eb0266a724e277f8adc4397b56ba98acf727/" target="_blank">Convertio - Download de v√≠deo convertido</a></li>
      <li><a href="https://www.geeksforgeeks.org/python/python-opencv-cv2-imread-method/" target="_blank">GeeksforGeeks - cv2.imread()</a></li>
      <li><a href="https://docs.opencv.org/3.4/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank">OpenCV Imgcodecs Reference</a></li>
    </ul>
  </div>

</div>
