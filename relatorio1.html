<div class="relatorio-container">
  <h2>Relat칩rio 1 - Captura de Imagem e V칤deo</h2>
  <h3><pre>
  Leonardo Severgnine Maioli - RA: 11201920579
  Ricardo Javurek Rihan - RA: 11201920897
  Tiago Luiz Silva de Araujo Pereira - RA: 11013316

  Laborat칩rio realizado dias 16 e 18 de Junho, relat칩rio finalizado dia 23 de Junho
  </pre></h3>
  <h2>Introdu칞칚o</h2>
  <p>
    Este primeiro relat칩rio tratou de experimentos focados em captura de im치gem e v칤deo atrav칠s de webcam, bem como sua manipula칞칚o, mudando cores,
    velocidade de captura e afins. Os experimentos realizados foram seguindo um roteiro apresentado em aula dividido em duas partes, e tinha como objetivo estudar o uso
    do OpenCV e nos familiarizar com a visualiza칞칚o e processamento de im치gem e v칤deo de forma geral. Foram fornecidos c칩digos para tomarmos como base, que modificamos
     durante o experimento para adequar ao que necessitavamos. Os arquivos abaixo foram fornecidos como roteiro para a atividade, contendo o PDF que seguimos para realizar os experimentos,
     os c칩digos iniciais e uma imm치gem e v칤deo que foram utilizados nos experimentos. Os experimentos consistiram inicialmente na leitura de im치gem e v칤deo, e ent칚o na captura das 
     mesmas atrav칠s de uma webcam conectada ao computador.
  </p>
  <h2>Arquivos base para reproduzir o procedimento:</h2>
  <ul>
    <li><a href="relatorio1/esza019_2025.2__Lab1_img_video_.pdf" download class="download-link">游늯 Baixar Roteiro (PDF)</a></li>
    <li><a href="relatorio1/Lab1_arquivos.zip" download class="download-link">游닍 Baixar C칩digos Fonte (ZIP)</a></li>
  </ul>

    <h2>Procedimentos Experimentais</h2>
      <!-- Parte 1 - A -->

  <p>
    O primeiro experimento consiste na leitura de uma im치gem utilizando o OpenCV. Para este, foram utilizadas a im치gem messi5.jpg e o c칩digo L1_1_img.py fornecidos acima. Para isto,
    o computador tem que ter o Python instalado, assim como OpenCV (pip install opencv-python) e numpy (pip install numpy). Feito isso, basta executar L1_1_img.py com o python, tendo
    a im치gem que ser치 lida (no nosso caso, messi5.jpg) na mesma pasta que o c칩digo. Ao realizarmos a leitura pela primeira vez, podemos ver que foi aberta uma janela do openCV que 
    exibe a im치gem, por칠m ela 칠 exibida em preto e branco: 
  </p>
  <div class="image-container">
    <img src="relatorio1/messi5Original.png" alt="Imagem na leitura original" class="relatorio-image">
    <p class="image-caption"><em>Im치gem lida pelo c칩digo original, sem modifica-lo</em></p>
  </div>
  <p>
    Como podemos ver, a im치gem veio em preto e branco. Vamos agora analisar o c칩digo utlilzado. Na primeira linha depois dos imports, temos um imread, passando como parametro o 
    caminho para nossa im치gem e em seguida um n칰mero, 0. Como podemos ver na documenta칞칚o do openCV, este segundo parametro que estamos passando trata da cor da im치gem. O 0 consiste
    no preto e branco, portanto foi por isso que nossa im치gem final apareceu desta forma. Para alterarmos isso podemos passar o parametro 1, que consiste no colorido padr칚o, ou podemos
    simplesmente n칚o passar mais nenhum argumento ap칩s o caminho da im치gem como o colorido 칠 o default do comando. Modificando nosso c칩digo, podemos ver como a im치gem 칠 lida novamente:
  </p>
  <div class="image-container">
    <img src="relatorio1/messi5.png" alt="Imagem" class="relatorio-image">
    <p class="image-caption"><em>Im치gem lida pelo c칩digo modificado</em></p>
  </div>
  Abaixo temos o c칩digo com a mudan칞a realizada:
  <div class="button-group">
    <button onclick="toggleSection('code1')">C칩digo 1 Modificado</button>
  </div>
  <div id="code1" class="relatorio-section" style="display: none;">
      <code><pre>
      import numpy as np
      import cv2 as cv

      img = cv.imread('messi5.jpg')
      cv.imshow('image',img)
      k = cv.waitKey(0)
      if k == 27:         # wait for ESC key to exit
          cv.destroyAllWindows()
      elif k == ord('s'): # wait for 's' key to save and exit
          cv.imwrite('messigray.png',img)
          cv.destroyAllWindows()
    </pre></code>
  </div>
  <!-- Parte 1 - B -->

  <p>
    Em seguida, realizamos um experimento semelhante mas tratando de leitura de v칤deo. Para isto, foram utilizados o segundo c칩digo e o v칤deo
    big_buck_bunny, ambos presentes nos arquivos fornecidos. Ao rodarmos o arquivo, podemos ver que o v칤deo j치 칠 apresentado normalmente e 
    em velocidade normal. Neste experimento, buscamos analisar como funciona a leitura de v칤deos pelo openCV. Para isto, vamos tentar alterar
    a velocidade de reprodu칞칚o do v칤deo. Vendo o c칩digo, que est치 inclusive comentado, podemos ver que a exibi칞칚o do v칤deo est치 sendo feita 
    por modo de exibi칞칚o de frames, um de cada vez e em sequ칡ncia. Portanto, se queremos alterar a velocidade do v칤deo, basta mudarmos o tempo
    que esperamos entre a exibi칞칚o de um frame e do pr칩ximo, portanto alterando o valor de time.sleep(1/25.0). Para demonstrar, alteramos o 
    valor para time.sleep(1/100.0), e como resultado ao rodar o programa tivemos um v칤deo acelerado: 
  </p>

  <video controls width="640">
    <source src="relatorio1/big_buck_bunny_accelerated.mp4" type="video/mp4">
  </video>

  <div class="button-group">
    <button onclick="toggleSection('code2')">C칩digo 2 Modificado</button>
  </div>
  <div id="code2" class="relatorio-section" style="display: none;">
    <code><pre>
      import time
      import numpy as np
      import cv2 as cv

      cap = cv.VideoCapture('big_buck_bunny.mp4')

      while(cap.isOpened()):
          ret, frame = cap.read()

          if ret==True:
              # show the frame
              cv.imshow('frame',frame)

              #wait next frame by 40ms - 25fps
              time.sleep(1/100.0) 

              if cv.waitKey(1) & 0xFF == ord('q'):
                  break
          else:
              break

      cap.release()
      cv.destroyAllWindows()cv.destroyAllWindows()
    </pre></code>
  </div>

    <!-- Parte 1 - C  e 2 - A e B -->
  <p>
    O proximo experimento consistiu em  conectar uma webcam ao computador e realizar a leitura e captura de im치gens atrav칠s desta. Para isso, 
    foi usado o programa 3 fornecido. O programa fornecido j치 칠 capaz de identificar a webcam e visualizar im치gens atrav칠s desta, ent칚o apenas 
    precisamos modifica-lo para salvar a im치gem que est치 sendo exibida quando quisermos. Para isso, utilizamos a fun칞칚o imwrite do openCV.
    Inicialmente tentamos inserir uma outra linha com if cv.waitKey(1), verificando se o valor era igual a x, e ent칚o realizando um imwrite 
    passando o nome desejado e o frame previamente definido. Esta solu칞칚o era capaz de salvar a imagem conforme desejado, mas notamos que 
    algumas vezes nosso click parecia n칚o ser registrado e s칩 algumas vezes a imagem era salva. Percebemos que isto acontecia porque como 
    t칤nhamos dois waitKeys, o programa estava alternando entre os dois e verificando apenas uma das teclas de cada vez. Para resolver este
    problema, definimos uma vari치vel como o valor da waitKey, fora dos ifs, e ent칚o realizamos a verifica칞칚o do valor da tecla recebida pela
    vari치vel. Por fim, definimos um img_counter e utilizamos ele para iterar o nome da foto, para podermos salvar v치rias fotos em seguida sem
    uma sobrescrever a outra por terem o mesmo nome. Utilizamos deste programa modificado para tirar fotos de todos do grupo:
  </p>

  <img class="profile-image" src="images/fotoDos3.png"></br>

  <div class="button-group">
    <button onclick="toggleSection('code3')">C칩digo 3 Modificado</button>
  </div>
  <div id="code3" class="relatorio-section" style="display: none;">
          <pre><code>
            import numpy as np
            import cv2 as cv

            cap = cv.VideoCapture(0)
            img_counter = 0

            if not cap.isOpened():
                print("Cannot open camera")
                exit()

            while True:
                # Capture frame-by-frame
                ret, frame = cap.read()
                # if frame is read correctly ret is True
                if not ret:
                    print("Can't receive frame (stream end?). Exiting ...")
                    break

                # Display the resulting frame
                cv.imshow('frame', frame)

                cvVal = cv.waitKey(1)
                if cvVal == ord('q'):
                    break
                elif cvVal == ord('x'):
                    img_name = "foto{}.png".format(img_counter)
                    cv.imwrite(img_name, frame)
                    img_counter +=1

            # When everything done, release the capture
            cap.release()
            cv.destroyAllWindows()
          </code></pre>
    </div>
    <p>
      Seguindo ainda o script no PDF, escolhemos "avatares" para cada integrante do grupo, mostrando eles aqui na mesma sequ칡ncia da foto:
    </p>
    <img class="profile-image" src="images/avatarDos3.png">

    <!-- Parte 1 - D  e 2 - C -->

    <p>
      Por fim, realizamos experimentos com captura de v칤deo. Para isso, tomamos como base o c칩digo 4 fornecido. Por칠m, podemos ver que ao 
      rodarmos este, podemos notar que a im치gem est치 sendo exibida de forma invertida, e o v칤deo salvo est치 muito mais lento que a velocidade
      real:
    </p>
    <video controls width="640">
        <source src="relatorio1/saida.mp4" type="video/mp4">
    </video>
    <p>
      Olhamos o c칩digo e vimos que o problema da imagem invertida se d치 pelo fato de usarem a fun칞칚o cv.flip() para realizarem a invers칚o do 
      frame do v칤deo, antes de rodar a fun칞칚o write() no objeto do VideoWriter criado. [ frame = cv.flip(frame, 0) ] J치 o problema da 
      velocidade reduzida se d치 pelo fato do FPS do VideoWriter estar setado com um valor baixo de 10 fps, e foi resolvido aumentando esse 
      valor para 30. Ap칩s realizarmos estas modifica칞칫es, utilizamos de nosso c칩digo alterado para gravar alguns v칤deos de teste:
    </p>
    <div class="video-section">
    <h2>V칤deos de Movimento</h2>

    <div class="video-container">
      <h3>Movimento r치pido - Membro</h3>
      <video controls muted width="640">
        <source src="videos/Movimento_rapido_membro.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento r치pido - Objeto</h3>
      <video controls muted width="640">
        <source src="videos/Movimento_rapido_objeto.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento lento - Membro</h3>
      <video controls muted width="640">
        <source src="videos/movimento-lento-membro.mp4" type="video/mp4">
      </video>
    </div>

    <div class="video-container">
      <h3>Movimento lento - Objeto</h3>
      <video controls muted width="640">
        <source src="videos/movimento-lento-objeto.mp4" type="video/mp4">
      </video>
    </div>
  </div>
  <div class="button-group">
    <button onclick="toggleSection('code4')">C칩digo 4 Modificado</button>
  </div>
  <div id="code4" class="relatorio-section" style="display: none;">
          <pre><code>
            import numpy as np
            import cv2 as cv
            cap = cv.VideoCapture(0)

            # Get current width of frame
            width = cap.get(cv.CAP_PROP_FRAME_WIDTH)   # float
            # Get current height of frame
            height = cap.get(cv.CAP_PROP_FRAME_HEIGHT) # float
            # Define Video Frame Rate in fps
            fps = 30.0

            # Define the codec and create VideoWriter object
            fourcc = cv.VideoWriter_fourcc(*'XVID')
            out = cv.VideoWriter('saida.avi', fourcc, fps, (int(width),int(height)) )

            while cap.isOpened():
                ret, frame = cap.read()
                if not ret:
                    print("Can't receive frame (stream end?). Exiting ...")
                    break
                frame = cv.flip(frame, 1)
                # write the flipped frame
                out.write(frame)
                cv.imshow('frame', frame)
                if cv.waitKey(1) == ord('q'):
                    break

            # Release everything if job is finished
            cap.release()
            out.release()
            cv.destroyAllWindows()
          </code></pre>
    </div>
    <h2>An치lise e Discuss칚o</h2>
    <p>
      A partir dos experimentos realizados, foi poss칤vel observar como par칙metros simples nos comandos do OpenCV, como o valor do 
      <code>imread()</code> ou a frequ칡ncia de <code>waitKey()</code> e <code>sleep()</code>, afetam diretamente a forma como as imagens e 
      v칤deos s칚o processados e exibidos. Durante os testes com captura de imagem, a import칙ncia de um controle adequado das teclas pressionadas
       ficou evidente, j치 que duplica칞칫es ou m치s leituras podem comprometer a funcionalidade esperada. Da mesma forma, a manipula칞칚o do v칤deo 
       mostrou que o entendimento de FPS e orienta칞칚o do frame (flip) 칠 essencial para obter resultados realistas. As altera칞칫es realizadas nos
        c칩digos base foram fundamentais para tornar os programas mais responsivos e adequados aos objetivos da atividade.
    </p>
  <h2>Conclus칫es</h2>
  <p>
    Este primeiro experimento permitiu uma introdu칞칚o pr치tica ao OpenCV, destacando aspectos importantes do processamento de imagens e v칤deos,
     como leitura, exibi칞칚o, modifica칞칚o e grava칞칚o. Ao trabalhar com diferentes formatos de entrada e sa칤da, o grupo p칪de compreender o 
     funcionamento interno das opera칞칫es b치sicas da biblioteca, al칠m de enfrentar e solucionar problemas comuns no uso de webcams e v칤deos.
      As atividades tamb칠m favoreceram o aprendizado pr치tico de conceitos como FPS, codificadores de v칤deo, e a influ칡ncia da intera칞칚o do 
      usu치rio sobre o comportamento dos programas. De forma geral, os objetivos da atividade foram atingidos com sucesso.
  </p>
    <div class="referencias">
    <h2>Refer칡ncias</h2>
    <ul>
      <li>MINICHINO, J.; HOWSE, J. <em>Learning OpenCV 3 Computer Vision with Python</em>, 2nd Ed, Packt Publishing, 2015.</li>
      <li><a href="https://docs.opencv.org/master/d6/d00/tutorial_py_root.html" target="_blank">Tutorial OpenCV e Python</a></li>
      <li><a href="https://docs.opencv.org/4.x/db/deb/tutorial_display_image.html" target="_blank">Getting Started with Images</a></li>
      <li><a href="https://docs.opencv.org/4.x/dd/d43/tutorial_py_video_display.html" target="_blank">Getting Started with Videos</a></li>
      <li><a href="https://convertio.co/pt/download/d7eb0266a724e277f8adc4397b56ba98acf727/" target="_blank">Convertio - Download de v칤deo convertido</a></li>
      <li><a href="https://www.geeksforgeeks.org/python/python-opencv-cv2-imread-method/" target="_blank">GeeksforGeeks - cv2.imread()</a></li>
      <li><a href="https://docs.opencv.org/3.4/d4/da8/group__imgcodecs.html#gabbc7ef1aa2edfaa87772f1202d67e0ce" target="_blank">OpenCV Imgcodecs Reference</a></li>
    </ul>
  </div>

</div>
